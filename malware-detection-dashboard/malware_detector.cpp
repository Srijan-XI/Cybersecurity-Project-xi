
// Malware Classification & Detection System - C++ Implementation
// Lightweight scanner using Windows/Linux APIs with ONNX runtime

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <memory>
#include <chrono>

// ONNX Runtime headers
#include <onnxruntime_cxx_api.h>

// Platform-specific headers
#ifdef _WIN32
    #include <windows.h>
    #include <winternl.h>
#else
    #include <unistd.h>
    #include <sys/stat.h>
#endif

class PEAnalyzerCpp {
private:
    std::vector<float> features;

public:
    struct PEFeatures {
        uint32_t file_size;
        uint32_t dos_header_size;
        uint16_t number_of_sections;
        uint32_t size_of_image;
        uint32_t checksum;
        uint16_t machine_type;
        uint32_t timestamp;
        std::vector<float> byte_entropy;
        std::vector<int> string_features;
    };

    PEFeatures extractFeatures(const std::string& filePath) {
        PEFeatures features = {};

        // Open file
        std::ifstream file(filePath, std::ios::binary);
        if (!file.is_open()) {
            std::cerr << "Error opening file: " << filePath << std::endl;
            return features;
        }

        // Get file size
        file.seekg(0, std::ios::end);
        features.file_size = file.tellg();
        file.seekg(0, std::ios::beg);

        // Read DOS header
        char dosHeader[64];
        file.read(dosHeader, 64);

        // Check PE signature
        if (dosHeader[0] != 'M' || dosHeader[1] != 'Z') {
            std::cerr << "Not a valid PE file" << std::endl;
            return features;
        }

        // Extract PE header information
        uint32_t peOffset = *reinterpret_cast<uint32_t*>(dosHeader + 60);
        file.seekg(peOffset);

        char peSignature[4];
        file.read(peSignature, 4);

        if (memcmp(peSignature, "PE\0\0", 4) != 0) {
            std::cerr << "Invalid PE signature" << std::endl;
            return features;
        }

        // Read COFF header
        char coffHeader[20];
        file.read(coffHeader, 20);

        features.machine_type = *reinterpret_cast<uint16_t*>(coffHeader);
        features.number_of_sections = *reinterpret_cast<uint16_t*>(coffHeader + 2);
        features.timestamp = *reinterpret_cast<uint32_t*>(coffHeader + 4);

        // Calculate byte entropy (simplified)
        file.seekg(0, std::ios::beg);
        std::vector<char> fileContent((std::istreambuf_iterator<char>(file)),
                                     std::istreambuf_iterator<char>());

        features.byte_entropy = calculateByteEntropy(fileContent);

        return features;
    }

private:
    std::vector<float> calculateByteEntropy(const std::vector<char>& data) {
        std::vector<int> byteCount(256, 0);

        // Count byte frequencies
        for (char byte : data) {
            byteCount[static_cast<unsigned char>(byte)]++;
        }

        // Calculate probabilities and entropy
        std::vector<float> entropy(256);
        double totalBytes = data.size();

        for (int i = 0; i < 256; i++) {
            if (byteCount[i] > 0) {
                double probability = byteCount[i] / totalBytes;
                entropy[i] = static_cast<float>(-probability * log2(probability));
            }
        }

        return entropy;
    }
};

class ONNXMalwareClassifier {
private:
    std::unique_ptr<Ort::Session> session;
    std::unique_ptr<Ort::Env> env;
    std::vector<const char*> inputNames;
    std::vector<const char*> outputNames;

public:
    ONNXMalwareClassifier(const std::string& modelPath) {
        // Initialize ONNX Runtime
        env = std::make_unique<Ort::Env>(ORT_LOGGING_LEVEL_WARNING, "MalwareDetection");

        Ort::SessionOptions sessionOptions;
        sessionOptions.SetIntraOpNumThreads(1);

        // Load model
#ifdef _WIN32
        std::wstring wideModelPath(modelPath.begin(), modelPath.end());
        session = std::make_unique<Ort::Session>(*env, wideModelPath.c_str(), sessionOptions);
#else
        session = std::make_unique<Ort::Session>(*env, modelPath.c_str(), sessionOptions);
#endif

        // Get input/output names
        inputNames.push_back("input");
        outputNames.push_back("output");
    }

    struct PredictionResult {
        std::string verdict;
        float confidence;
        float malwareProb;
        float benignProb;
    };

    PredictionResult predict(const std::vector<float>& features) {
        PredictionResult result;

        try {
            // Create input tensor
            std::vector<int64_t> inputShape = {1, static_cast<int64_t>(features.size())};

            auto memoryInfo = Ort::MemoryInfo::CreateCpu(OrtArenaAllocator, OrtMemTypeDefault);
            auto inputTensor = Ort::Value::CreateTensor<float>(
                memoryInfo, 
                const_cast<float*>(features.data()), 
                features.size(), 
                inputShape.data(), 
                inputShape.size()
            );

            // Run inference
            auto outputTensors = session->Run(
                Ort::RunOptions{nullptr},
                inputNames.data(),
                &inputTensor,
                1,
                outputNames.data(),
                1
            );

            // Extract results
            float* outputData = outputTensors[0].GetTensorMutableData<float>();
            result.malwareProb = outputData[0];
            result.benignProb = 1.0f - outputData[0];

            result.confidence = std::max(result.malwareProb, result.benignProb);
            result.verdict = (result.malwareProb > 0.5) ? "malware" : "benign";

        } catch (const std::exception& e) {
            std::cerr << "Prediction error: " << e.what() << std::endl;
            result.verdict = "error";
            result.confidence = 0.0f;
        }

        return result;
    }
};

class MalwareDetectionSystemCpp {
private:
    PEAnalyzerCpp peAnalyzer;
    std::unique_ptr<ONNXMalwareClassifier> classifier;

public:
    MalwareDetectionSystemCpp(const std::string& modelPath) {
        classifier = std::make_unique<ONNXMalwareClassifier>(modelPath);
    }

    struct AnalysisResult {
        std::string filename;
        std::string verdict;
        float confidence;
        double analysisTime;
        std::vector<std::string> recommendations;
    };

    AnalysisResult analyzeFile(const std::string& filePath) {
        auto startTime = std::chrono::high_resolution_clock::now();

        AnalysisResult result;
        result.filename = filePath.substr(filePath.find_last_of("/\\") + 1);

        // Extract features
        auto peFeatures = peAnalyzer.extractFeatures(filePath);

        // Convert to feature vector for ML model
        std::vector<float> featureVector;
        featureVector.push_back(static_cast<float>(peFeatures.file_size));
        featureVector.push_back(static_cast<float>(peFeatures.number_of_sections));
        featureVector.push_back(static_cast<float>(peFeatures.machine_type));

        // Add entropy features
        featureVector.insert(featureVector.end(), 
                           peFeatures.byte_entropy.begin(), 
                           peFeatures.byte_entropy.end());

        // Pad/truncate to expected size (e.g., 85 features)
        featureVector.resize(85, 0.0f);

        // Run ML prediction
        auto prediction = classifier->predict(featureVector);
        result.verdict = prediction.verdict;
        result.confidence = prediction.confidence;

        // Generate recommendations
        if (result.verdict == "malware") {
            result.recommendations = {
                "QUARANTINE: Isolate file immediately",
                "SCAN: Perform full system scan",
                "INVESTIGATE: Check for lateral movement"
            };
        } else if (result.verdict == "benign") {
            if (result.confidence < 0.8) {
                result.recommendations = {
                    "MONITOR: Low confidence - continue monitoring"
                };
            }
        }

        auto endTime = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
        result.analysisTime = duration.count() / 1000.0;

        return result;
    }
};

// Usage example
int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <model_path> <file_to_analyze>" << std::endl;
        return 1;
    }

    std::string modelPath = argv[1];
    std::string filePath = argv[2];

    try {
        MalwareDetectionSystemCpp detector(modelPath);
        auto result = detector.analyzeFile(filePath);

        std::cout << "Analysis Results:" << std::endl;
        std::cout << "=================" << std::endl;
        std::cout << "File: " << result.filename << std::endl;
        std::cout << "Verdict: " << result.verdict << std::endl;
        std::cout << "Confidence: " << (result.confidence * 100) << "%" << std::endl;
        std::cout << "Analysis Time: " << result.analysisTime << "s" << std::endl;

        if (!result.recommendations.empty()) {
            std::cout << "Recommendations:" << std::endl;
            for (size_t i = 0; i < result.recommendations.size(); i++) {
                std::cout << "  " << (i + 1) << ". " << result.recommendations[i] << std::endl;
            }
        }

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}

/*
Compilation Instructions:
========================

Windows (Visual Studio):
1. Install ONNX Runtime NuGet package
2. Add include directories and libraries
3. Compile: cl malware_detector.cpp /I"path_to_onnxruntime/include" /link onnxruntime.lib

Linux (GCC):
1. Download ONNX Runtime for Linux
2. Extract and set paths
3. Compile: g++ -std=c++14 malware_detector.cpp -I/path/to/onnxruntime/include -L/path/to/onnxruntime/lib -lonnxruntime -o malware_detector

Usage:
======
./malware_detector model.onnx suspicious_file.exe
*/
