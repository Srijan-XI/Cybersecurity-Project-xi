// Simplified Malware Detection System - No ONNX Runtime required
// This version uses simple heuristics instead of ML models

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <chrono>
#include <algorithm>
#include <cmath>
#include <map>

// Platform-specific headers
#ifdef _WIN32
    #include <windows.h>
#else
    #include <unistd.h>
    #include <sys/stat.h>
#endif

class SimpleFileAnalyzer {
private:
    std::vector<float> features;

public:
    struct FileFeatures {
        uint32_t file_size;
        double entropy;
        bool has_pe_signature;
        bool has_exe_extension;
        std::map<std::string, bool> suspicious_strings;
    };

    FileFeatures extractFeatures(const std::string& filePath) {
        FileFeatures features = {};
        features.suspicious_strings["CreateRemoteThread"] = false;
        features.suspicious_strings["VirtualAlloc"] = false;
        features.suspicious_strings["ShellExecute"] = false;
        features.suspicious_strings["WriteProcessMemory"] = false;
        features.suspicious_strings["URLDownloadToFile"] = false;

        // Check file extension
        std::string extension = filePath.substr(filePath.find_last_of('.') + 1);
        std::transform(extension.begin(), extension.end(), extension.begin(), ::tolower);
        features.has_exe_extension = (extension == "exe" || extension == "dll" || extension == "scr");

        // Open file
        std::ifstream file(filePath, std::ios::binary);
        if (!file.is_open()) {
            std::cerr << "Error opening file: " << filePath << std::endl;
            return features;
        }

        // Get file size
        file.seekg(0, std::ios::end);
        features.file_size = file.tellg();
        file.seekg(0, std::ios::beg);

        // Read entire file content
        std::vector<char> buffer(features.file_size);
        file.read(buffer.data(), features.file_size);

        // Check PE signature
        if (buffer.size() > 64) {
            if (buffer[0] == 'M' && buffer[1] == 'Z') {
                features.has_pe_signature = true;
                
                // Check for PE header offset
                uint32_t peOffset = *reinterpret_cast<uint32_t*>(&buffer[60]);
                if (peOffset < buffer.size() - 4) {
                    if (buffer[peOffset] == 'P' && buffer[peOffset+1] == 'E' && 
                        buffer[peOffset+2] == 0 && buffer[peOffset+3] == 0) {
                        // Confirmed PE file
                    }
                }
            }
        }

        // Calculate entropy
        features.entropy = calculateEntropy(buffer);

        // Check for suspicious strings
        std::string fileContent(buffer.begin(), buffer.end());
        for (auto& pair : features.suspicious_strings) {
            if (fileContent.find(pair.first) != std::string::npos) {
                pair.second = true;
            }
        }

        return features;
    }

    double calculateEntropy(const std::vector<char>& data) {
        if (data.empty()) return 0.0;

        std::vector<int> byteFreq(256, 0);
        
        // Count occurrences of each byte value
        for (char b : data) {
            byteFreq[static_cast<unsigned char>(b)]++;
        }
        
        double entropy = 0.0;
        double fileSize = static_cast<double>(data.size());
        
        // Calculate Shannon entropy
        for (int count : byteFreq) {
            if (count > 0) {
                double probability = static_cast<double>(count) / fileSize;
                entropy -= probability * std::log2(probability);
            }
        }
        
        return entropy;
    }
};

class SimpleMalwareDetector {
private:
    SimpleFileAnalyzer analyzer;
    
    // Heuristic thresholds
    const double HIGH_ENTROPY_THRESHOLD = 7.0;
    const int MIN_SUSPICIOUS_STRINGS = 2;
    const uint32_t SUSPICIOUS_SIZE_MIN = 20000;
    const uint32_t SUSPICIOUS_SIZE_MAX = 5000000;

public:
    struct AnalysisResult {
        std::string filename;
        std::string verdict;
        double confidence;
        double analysisTime;
        std::vector<std::string> indicators;
        std::vector<std::string> recommendations;
    };

    AnalysisResult analyzeFile(const std::string& filePath) {
        auto startTime = std::chrono::high_resolution_clock::now();
        
        AnalysisResult result;
        result.filename = filePath.substr(filePath.find_last_of("/\\") + 1);
        result.indicators.clear();
        result.confidence = 0.0;
        
        // Extract features
        auto fileFeatures = analyzer.extractFeatures(filePath);
        
        // Count suspicious indicators
        int suspiciousScore = 0;
        int maxScore = 0;
        
        // Check entropy
        maxScore++;
        if (fileFeatures.entropy > HIGH_ENTROPY_THRESHOLD) {
            suspiciousScore++;
            result.indicators.push_back("High entropy: " + std::to_string(fileFeatures.entropy));
        }
        
        // Check suspicious strings
        int suspiciousStrings = 0;
        for (const auto& pair : fileFeatures.suspicious_strings) {
            maxScore++;
            if (pair.second) {
                suspiciousStrings++;
                suspiciousScore++;
                result.indicators.push_back("Suspicious API: " + pair.first);
            }
        }
        
        // Check file size
        maxScore++;
        if (fileFeatures.file_size > SUSPICIOUS_SIZE_MIN && 
            fileFeatures.file_size < SUSPICIOUS_SIZE_MAX) {
            suspiciousScore++;
            result.indicators.push_back("Suspicious file size: " + 
                                      std::to_string(fileFeatures.file_size) + " bytes");
        }
        
        // Check if it's an executable
        maxScore++;
        if (fileFeatures.has_pe_signature && fileFeatures.has_exe_extension) {
            suspiciousScore++;
            result.indicators.push_back("Executable file detected");
        }
        
        // Calculate confidence
        result.confidence = static_cast<double>(suspiciousScore) / maxScore;
        
        // Determine verdict
        if (result.confidence > 0.7) {
            result.verdict = "malware";
            result.recommendations = {
                "QUARANTINE: Isolate file immediately",
                "SCAN: Perform full system scan",
                "INVESTIGATE: Check for related processes"
            };
        } else if (result.confidence > 0.4) {
            result.verdict = "suspicious";
            result.recommendations = {
                "MONITOR: Review file behavior",
                "ANALYZE: Submit for deeper analysis"
            };
        } else {
            result.verdict = "benign";
            if (result.confidence > 0.2) {
                result.recommendations = {
                    "MONITOR: Low confidence - continue monitoring"
                };
            } else {
                result.recommendations = {
                    "SAFE: File appears to be benign"
                };
            }
        }
        
        // Calculate analysis time
        auto endTime = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
        result.analysisTime = duration.count() / 1000.0;
        
        return result;
    }
};

// Main function
int main(int argc, char* argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <file_to_analyze>" << std::endl;
        return 1;
    }

    std::string filePath = argv[1];

    try {
        SimpleMalwareDetector detector;
        auto result = detector.analyzeFile(filePath);

        std::cout << "Analysis Results:" << std::endl;
        std::cout << "=================" << std::endl;
        std::cout << "File: " << result.filename << std::endl;
        std::cout << "Verdict: " << result.verdict << std::endl;
        std::cout << "Confidence: " << (result.confidence * 100) << "%" << std::endl;
        std::cout << "Analysis Time: " << result.analysisTime << "s" << std::endl;

        if (!result.indicators.empty()) {
            std::cout << "Indicators:" << std::endl;
            for (const auto& indicator : result.indicators) {
                std::cout << "  - " << indicator << std::endl;
            }
        }

        if (!result.recommendations.empty()) {
            std::cout << "Recommendations:" << std::endl;
            for (size_t i = 0; i < result.recommendations.size(); i++) {
                std::cout << "  " << (i + 1) << ". " << result.recommendations[i] << std::endl;
            }
        }

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}