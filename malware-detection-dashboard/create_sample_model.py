# Create a sample ONNX model for the malware detector
# This script creates a simple ML model to use for testing the C++ code

import os
import sys
import numpy as np

def install_package(package_name):
    """Install a package using pip"""
    import subprocess
    try:
        print(f"Installing {package_name}...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", package_name])
        return True
    except subprocess.CalledProcessError as e:
        print(f"Failed to install {package_name}: {e}")
        return False

# Check for required libraries and install if needed
try:
    import onnxruntime as ort
except ImportError:
    print("ONNX Runtime not found. Installing...")
    if not install_package("onnxruntime"):
        print("Failed to install onnxruntime. Please install manually.")
        sys.exit(1)
    import onnxruntime as ort

try:
    from sklearn.ensemble import RandomForestClassifier
    from sklearn.model_selection import train_test_split
except ImportError:
    print("Scikit-learn not found. Installing...")
    if not install_package("scikit-learn"):
        print("Failed to install scikit-learn. Please install manually.")
        sys.exit(1)
    from sklearn.ensemble import RandomForestClassifier
    from sklearn.model_selection import train_test_split

try:
    from skl2onnx import convert_sklearn
    from skl2onnx.common.data_types import FloatTensorType
except ImportError:
    print("skl2onnx not found. Installing...")
    if not install_package("skl2onnx"):
        print("Failed to install skl2onnx. Please install manually.")
        sys.exit(1)
    from skl2onnx import convert_sklearn
    from skl2onnx.common.data_types import FloatTensorType

def create_sample_model():
    """Create a sample ONNX model for malware detection testing"""
    print("Creating a sample ONNX model for testing...")
    
    try:
        # Create directories if they don't exist
        models_dir = os.path.join("onnxruntime", "models")
        os.makedirs(models_dir, exist_ok=True)
        print(f"Created directory: {models_dir}")
        
        # Generate synthetic training data that mimics real malware features
        print("Generating synthetic training data...")
        n_samples = 1000
        n_features = 85  # Match the C++ code expectation
        
        # Create more realistic feature distributions
        np.random.seed(42)  # For reproducibility
        
        # Generate features with different distributions to simulate real PE features
        X_train = np.zeros((n_samples, n_features), dtype=np.float32)
        
        # File size features (normalized)
        X_train[:, 0] = np.random.lognormal(10, 2, n_samples).astype(np.float32)
        
        # Entropy features (0-8 range)
        X_train[:, 1:10] = np.random.uniform(0, 8, (n_samples, 9)).astype(np.float32)
        
        # Binary features (0 or 1)
        X_train[:, 10:20] = np.random.binomial(1, 0.3, (n_samples, 10)).astype(np.float32)
        
        # API count features
        X_train[:, 20:50] = np.random.poisson(5, (n_samples, 30)).astype(np.float32)
        
        # Remaining features with normal distribution
        X_train[:, 50:] = np.random.normal(0, 1, (n_samples, 35)).astype(np.float32)
        
        # Normalize features to reasonable ranges
        X_train = np.clip(X_train, 0, 100)
        
        # Generate labels based on feature combinations (more realistic)
        # High entropy + many suspicious APIs = likely malware
        malware_score = (
            (X_train[:, 1] > 6) * 0.3 +  # High entropy
            (X_train[:, 20:30].sum(axis=1) > 20) * 0.4 +  # Many API calls
            np.random.random(n_samples) * 0.3  # Some randomness
        )
        
        y_train = (malware_score > 0.5).astype(int)
        
        print(f"Generated {n_samples} samples with {n_features} features")
        print(f"Malware samples: {np.sum(y_train)}, Benign samples: {np.sum(1-y_train)}")
        
        # Split data for training and validation
        X_train_split, X_val, y_train_split, y_val = train_test_split(
            X_train, y_train, test_size=0.2, random_state=42, stratify=y_train
        )
        
        # Train a Random Forest model
        print("Training Random Forest model...")
        clf = RandomForestClassifier(
            n_estimators=50,
            max_depth=10,
            min_samples_split=5,
            min_samples_leaf=2,
            random_state=42
        )
        clf.fit(X_train_split, y_train_split)
        
        # Evaluate the model
        train_score = clf.score(X_train_split, y_train_split)
        val_score = clf.score(X_val, y_val)
        print(f"Training accuracy: {train_score:.3f}")
        print(f"Validation accuracy: {val_score:.3f}")
        
        # Convert to ONNX format
        print("Converting model to ONNX format...")
        initial_type = [('input', FloatTensorType([None, n_features]))]
        
        try:
            onnx_model = convert_sklearn(
                clf, 
                initial_types=initial_type, 
                target_opset=12,  # Use a more stable opset version
                options={id(clf): {'zipmap': False}}  # Disable zipmap for binary classification
            )
        except Exception as e:
            print(f"Error during ONNX conversion: {e}")
            print("Trying with different options...")
            onnx_model = convert_sklearn(
                clf, 
                initial_types=initial_type, 
                target_opset=11
            )
        
        # Save the model
        model_path = os.path.join(models_dir, "test_model.onnx")
        with open(model_path, "wb") as f:
            f.write(onnx_model.SerializeToString())
        
        print(f"Sample model created and saved to {model_path}")
        
        # Test the model with ONNX Runtime
        print("Testing model with ONNX Runtime...")
        try:
            session = ort.InferenceSession(model_path)
            input_name = session.get_inputs()[0].name
            output_name = session.get_outputs()[0].name
            
            print(f"Model input name: {input_name}")
            print(f"Model output name: {output_name}")
            print(f"Input shape: {session.get_inputs()[0].shape}")
            print(f"Output shape: {session.get_outputs()[0].shape}")
            
            # Test with a few samples
            test_samples = X_val[:3]
            for i, sample in enumerate(test_samples):
                test_input = sample.reshape(1, -1)
                result = session.run([output_name], {input_name: test_input})
                predicted_class = result[0][0]
                actual_class = y_val[i]
                print(f"Test sample {i+1}: Predicted={predicted_class}, Actual={actual_class}")
            
            print("✅ Model successfully verified with ONNX Runtime")
            print(f"✅ Model ready for use with C++ detector")
            return True
            
        except Exception as e:
            print(f"❌ Error testing the model: {e}")
            return False
            
    except Exception as e:
        print(f"❌ Error creating model: {e}")
        import traceback
        traceback.print_exc()
        return False

def main():
    """Main function to create and validate the ONNX model"""
    print("=" * 60)
    print("ONNX Malware Detection Model Generator")
    print("=" * 60)
    
    # Check if we're in the right directory
    if not os.path.exists("malware_detector.cpp"):
        print("⚠️  Warning: malware_detector.cpp not found in current directory")
        print("   Make sure you're running this script from the project root")
    
    # Create the model
    success = create_sample_model()
    
    if success:
        print("\n" + "=" * 60)
        print("✅ SUCCESS: Model creation completed!")
        print("=" * 60)
        print("Next steps:")
        print("1. Run: .\\setup_onnx_runtime.ps1")
        print("2. Compile: g++ malware_detector.cpp -o malware_detector -I\".\\onnxruntime\\include\" -L\".\\onnxruntime\\lib\" -lonnxruntime")
        print("3. Test: .\\malware_detector.exe onnxruntime\\models\\test_model.onnx demo_files\\suspicious_tool.exe")
    else:
        print("\n" + "=" * 60)
        print("❌ FAILED: Model creation failed!")
        print("=" * 60)
        print("Troubleshooting:")
        print("1. Make sure you have internet connection for package downloads")
        print("2. Try running: pip install scikit-learn onnxruntime skl2onnx")
        print("3. Check if you have sufficient disk space")
        
    print("=" * 60)

if __name__ == "__main__":
    main()